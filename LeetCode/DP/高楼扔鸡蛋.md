给k个鸡蛋，有N层楼， 高于F层扔下鸡蛋会碎，低于F层的都不会碎，0<=F<=N
最坏情况下，至少扔几次鸡蛋，才能确定这个F?

这一题有一点值得注意就是在i层丢下，鸡蛋还没碎，那么还可以继续使用！！！

如果没有限定K个鸡蛋，那么用二分查找肯定是最少的。

什么是最坏情况？ 如果在1楼扔，鸡蛋就坏了，只需要扔1次，那么运气好，不算最坏情况，最坏情况是扔到N楼了还没坏，需要扔N次；
   所以最坏情况是穷尽区间

那么题目又规定至少多少次，这就涉及到策略选择了。

可以使用动态规划：选择第i层扔，如果碎了，那么就是k-1个鸡蛋试探0~i-1楼了，如果没碎，那么就是k个鸡蛋试探i~n楼
这就是子问题了

状态 ： k个鸡蛋N层楼 最坏情况下至少扔dp[k][n]次鸡蛋
选择 ： 选择在第几层扔？
base case: 
    只有一个鸡蛋时，只能从0往上扔，没坏还可以再扔， 最坏的情况下要扔 n次
    则：
    for(int i = 0; i<=N; i++) dp[1][i] = i;

    只有0层楼的时候；不用试:dp[i][0] = 0;
    只有0个鸡蛋；不存在的，题目说了鸡蛋的个数至少为1；

```cpp
//全局备忘录
vector<vector<int>>mem(k+1, vector<int>(N+1,-1));

int EggDrop(int k, int N) {
    return dp(k,n);
}

//k个鸡蛋试n次要试多少次（最坏情况，最少的次数）
 int dp(int k, int n) {
    if(k == 1) return n;
    if(n == 0) return 0;
    
    if(dp[k][n] != -1) return dp[k][n];
    int res = INT_MAX;

    //做选择： 选择在那一层扔，扔了就有两种情况，碎了或没碎！！
    for(int i = 1; i<= n; i++) {
        //最坏的情况下，最少的次数；；；最坏的情况取第i层碎或没碎导致的最大次数，因为第i层碎了或没碎都还得计算，因为还没找到最终的F层
        res = min(res, 
                max(dp(k, n -i),     //第i层没碎， 搜索的位置从i+1 ~ n，共n-i层
                    dp(k -1, i-1)   //第i层碎了   
                ) + 1   //第i次扔了1次
        )
    }
    dp[k][n] = res;
    return res;
 }

```

解法二： 
dp[k][m] = n;   dp数组定义为给你k个鸡蛋，最多测试m次，最高能测试的楼为n；  当n == N时，求出m不就是解！！！

照这样的定义：扔了鸡蛋碎或没碎两种情况下，能达到的最高楼层是
dp[k][m]= p[k-1][m-1]       //碎了，鸡蛋-1， 次数-1
             + dp[k][m-1]   //没碎，次数-1
                  + 1 ;     //试了一层，楼层 + 1

base case:  dp[][0] = 0;  dp[0][] = 0;

```cpp

int EggDrop(int k , int n) {

    //m最多能不会超过n的，因为一层一层的往上试也不会超过n
    vector<vector<int>> dp(k+1, vector<n+1, 0>);

    int m = 0;
    for(int m = 1; dp[k][m]< n; m++) {

        //i个鸡蛋m次尝试能到达第几层
        for(int i= 1； i<=k; i++) {
            dp[i][m] = dp[i-1][m-1] + dp[i][m-1] +1;
        }
        
    }
    return m;
} 


```