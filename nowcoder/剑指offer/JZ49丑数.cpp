求按从小到大的顺序的第n个丑数

丑数只能从 x1 * 2 ； x2 * 3; x3 * 5之中产生；
那么如何得到所有丑数呢？ 现在假设有3个数组，分别是：
A：{1*2，2*2，3*2，4*2，5*2，6*2，8*2，10*2......}

B：{1*3，2*3，3*3，4*3，5*3，6*3，8*3，10*3......}

C：{1*5，2*5，3*5，4*5，5*5，6*5，8*5，10*5......}

那么所有丑数的排列，必定就是上面ABC3个数组的合并结果然后去重得到的，那么这不就转换成了三个有序数组的无重复元素合并的问题了吗？
而这三个数组就刚好是{1,2,3,4,5,6,8,10....}乘以2,3,5得到的。
合并有序数组的一个比较好的方法，就是每个数组都对应一个指针，**然后比较这些指针所指的数中哪个最小**，就将这个数放到结果数组中，然后该指针向后挪一位。
为了去重，如果多个相等，那么都要后移！！！！！！
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int>dp(n+1,0);
        dp[1] = 1;
        int a = 1, b = 1, c = 1;
        for(int i =2; i<= n; i++) {
            int aa = dp[a] *2;
            int bb = dp[b] *3;
            int cc = dp[c] *5;
            dp[i]= min(min(aa,bb),cc);
            if(dp[i] == aa) a++;
            if(dp[i] == bb) b++;
            if(dp[i] == cc) c++;
        }
        return dp[n];
    }
};